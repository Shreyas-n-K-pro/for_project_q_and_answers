<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts and Applications</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        ul li p {
            margin-left: 20px; /* Optional for better readability */
            display: block;
        }
    </style>
</head>
<body>
    <header>
        <h1>Algorithm Concepts and Applications</h1>
        <p>A detailed overview of how algorithms relate to everyday problems and advanced scenarios.</p>
    </header>
   <!--<nav>
        <ul>
           
            <li><a href="#nature-problems">Problems in Nature</a></li>
            <li><a href="#efficiency">Efficiency Measures</a></li>
            <li><a href="#fundamental-techniques">Fundamental Techniques</a></li>
            <li><a href="#tree-structures">Tree Data Structures</a></li>
            <li><a href="#array-queries">Array Query Algorithms</a></li>
            <li><a href="#sorting-algorithms">Sorting Algorithms</a></li>
            <li><a href="#searching-algorithms">Searching Algorithms</a></li>
            <li><a href="#spanning-trees">Spanning Trees</a></li>
            <li><a href="#shortest-paths">Shortest Path Algorithms</a></li>
            <li><a href="#sorting">Sorting Algorithms</a></li>
            <li><a href="#searching">Searching Algorithms</a></li>
            <li><a href="#stringMatching">String Matching Algorithms</a></li>
            <li><a href="#graph">Graph Algorithms</a></li>
            <li><a href="#optimization">Optimization</a></li>

        </ul>
    </nav>     -->
    <main>
        <section id="nature-problems">
            <h2>1. Problems We See in Nature Related to Algorithms</h2>
            <ul>
                <li>Searching for food in a menu.</li>
                <li>Arranging vegetables from the market.</li>
                <li>Adding ingredients while preparing food.</li>
                <li>Finding a lost key (search problem).</li>
                <li>Drawing rangoli patterns (recursion).</li>
                <li>Cleaning the floor (Breadth-First Search).</li>
                <li>Traveling to new locations (Shortest Path Algorithm).</li>
            </ul>
        </section>
        <section id="efficiency">
            <h2>2. Time and Space Efficiency</h2>
            <p>Time-efficiency is the amount of time the basic operation/algorithm takes to execute as a function of input size or its magnitude. 
            Space-efficiency is the extra memory taken by the algorithm. 
            Both are important for designing sustainable solutions.</p>
            <h3>Orders of Growth</h3>
            <p>The growth rates of algorithms are classified as:</p>
            <pre>O(1) < O(log(n)) < O(n) < O(n log(n)) < O(n²) < O(n³) < O(2ⁿ) < O(n!)</pre>
        </section>
        <section id="fundamental-techniques">
            <h2>3. Fundamental Techniques</h2>
            <ul>
                <li><strong>Decomposition:</strong> Break complex problems into smaller, manageable sub-problems for focused solutions.</li>
                <li><strong>Pattern Recognition:</strong> Identify recurring patterns to generalize solutions and apply knowledge across domains.</li>
                <li><strong>Abstraction:</strong> Focus on essential features while ignoring irrelevant details to simplify problem-solving.</li>
                <li><strong>Traversal Techniques:</strong></li>
                <ul>
                    <li>Brave Traversal: Depth-first exploration (DFS).</li>
                    <li>Cautious Traversal: Level-wise exploration (BFS).</li>
                </ul>
                <li><strong>Pruning:</strong> Eliminate unnecessary parts of a problem to improve efficiency (e.g., N-Queens problem).</li>
                <li><strong>Lazy Propagation:</strong> Optimize range updates in data structures by deferring computations.</li>
                <li><strong>Sliding Window:</strong> Efficiently analyze overlapping sub-arrays or sequences.</li>
                <li><strong>Level Order Traversal:</strong> Explore tree nodes breadth-wise (used in BFS).</li>
                <li><strong>Hierarchical Data:</strong> Organize data in parent-child relationships for efficient management (e.g., tree structures).</li>
                <li><strong>Edge Relaxation:</strong> Update shortest path estimates in weighted graphs.</li>
                <li><strong>Balancing and Rotations:</strong> Maintain balanced trees for optimal performance (e.g., AVL, Red-Black trees).</li>
                <li><strong>Kleene Closure:</strong> Apply transitive properties for pathfinding and graph analysis.</li>
                <li><strong>Pre-Computing:</strong> Store frequently used results to avoid redundant calculations (e.g., lookup tables).</li>
                <li><strong>Parental Dominance:</strong> Maintain parent-child relationships for efficiency (e.g., heaps).</li>
                <li><strong>Prefix and Suffix:</strong> Useful for string manipulation and pattern matching.</li>
                <li><strong>Partitioning:</strong> Divide problems into smaller parts for efficient solutions (e.g., divide-and-conquer).</li>
                <li><strong>Bit Manipulations:</strong> Perform low-level binary operations for optimized algorithms.</li>
                <li><strong>Memoization:</strong> Store results of recursive calls to avoid redundant computations (dynamic programming).</li>
                <li><strong>Invariants:</strong> Ensure conditions remain constant to validate algorithms.</li>
                <li><strong>Shortest Path Trees:</strong> Represent shortest paths in graphs for routing and optimization tasks.</li>
            </ul>
        </section>
        <section id="tree-structures">
            <h2>4. Tree Data Structures</h2>
            <p>Hierarchical data structures help solve and optimize various problems:</p>
            <ul>
                <li><strong>Tree:</strong> Basic structure for relationships.</li>
                <li><strong>Binary Search Tree (BST):</strong> Ordered structure for efficient search, insert, and delete operations.</li>
                <li><strong>2-3 Tree:</strong> Always balanced for consistent performance.</li>
                <li><strong>AVL Tree:</strong> Self-balances for faster searches.</li>
                <li><strong>Red-Black Tree:</strong> Faster insertions and deletions due to simpler balancing.</li>
                <li><strong>Trie:</strong> Ideal for word searches and prefix matches.</li>
                <li><strong>Heap:</strong> Efficient for finding min/max in priority queues.</li>
            </ul>
        </section>
      <section id="array-queries">
    <h2>5. Array Query Algorithms</h2>
    <p>Array query algorithms handle range queries and updates effectively by using efficient data structures:</p>
    <ul>
        <li>
            <strong>Lookup Table</strong>
            <p><strong>Principle:</strong> Precomputes answers for different inputs and stores them in a table. 
                When queried, answers are retrieved in O(1) time using a 2D matrix.</p>
            <p><strong>Application:</strong> Useful when we need to answer multiple queries very quickly after an 
                initial precomputation (e.g., computing factorials).</p>
        </li>
        <li>
            <strong>Segment Tree</strong>
            <p><strong>Principle:</strong> A tree-like data structure that divides the array into smaller parts 
                (segments) and stores information about them. It can quickly answer range queries (like sum or 
                minimum) and also update elements.</p>
            <p><strong>Application:</strong> Used in problems involving arrays to answer range queries, such as in 
                games or dynamic programming problems.</p>
        </li>
        <li>
            <strong>Sparse Table</strong>
            <p><strong>Principle:</strong> Optimized for answering range queries where no updates are needed. It uses 
                precomputation to quickly find minimums or maximums over a range.</p>
            <p><strong>Application:</strong> Ideal for answering static range queries efficiently (e.g., finding the 
                minimum or maximum over a range).</p>
        </li>
        <li>
            <strong>Binary Indexed Tree (Fenwick Tree)</strong>
            <p><strong>Principle:</strong> A binary tree structure that helps quickly compute prefix sums (sum of 
                elements from the start of the array to a specific index) and update elements in the array.</p>
            <p><strong>Application:</strong> Used in problems requiring efficient updates and prefix sum queries, like 
                stock price tracking.</p>
        </li>
    </ul>
</section>
<section id="sorting-algorithms">
            <h2>6. Sorting Algorithms</h2>
            <p>Sorting helps organize data, making it easier to search, process, or analyze.</p>

            <ul>
                <li>
                    <span class="algorithm">Bubble Sort</span>
                    <p class="principle"><strong>Technique:</strong> Compares adjacent elements and swaps them if they are in the wrong order. Repeats until no swaps are needed.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Like bubbling the smallest objects to the surface when shaking a jar of mixed items.</p>
                </li>
                <li>
                    <span class="algorithm">Selection Sort</span>
                    <p class="principle"><strong>Technique:</strong> Finds the smallest (or largest) element and places it at the correct position in the sorted list, repeating for all elements.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Selecting the cheapest items from a shelf and arranging them in price order.</p>
                </li>
                <li>
                    <span class="algorithm">Insertion Sort</span>
                    <p class="principle"><strong>Technique:</strong> Picks one item at a time from the unsorted portion and places it in the correct position in the sorted portion.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Sorting playing cards in your hand while playing a game.</p>
                </li>
                <li>
                    <span class="algorithm">Merge Sort</span>
                    <p class="principle"><strong>Technique:</strong> Divides the list into halves, sorts each half, and merges the sorted halves.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Merging two sorted piles of papers into one sorted pile.</p>
                </li>
                <li>
                    <span class="algorithm">Quick Sort</span>
                    <p class="principle"><strong>Technique:</strong> Picks a "pivot" and rearranges items into smaller or larger groups based on the pivot. Recursively sorts each group.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Organizing books on a shelf by picking a reference book and grouping others around it.</p>
                </li>
                <li>
                    <span class="algorithm">Heap Sort</span>
                    <p class="principle"><strong>Technique:</strong> Builds a special tree (heap) to always extract the largest or smallest item and sort the list.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Organizing tasks by priority and completing the most urgent ones first.</p>
                </li>
            </ul>
        </section>

        <section id="searching-algorithms">
            <h2>Searching Algorithms</h2>
            <p>Searching helps locate specific information quickly in large datasets.</p>

            <ul>
                <li>
                    <span class="algorithm">Boyer-Moore Algorithm</span>
                    <p class="principle"><strong>Technique:</strong> Skips unnecessary comparisons when searching for a pattern in a text by using the last occurrence of characters.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Skimming through a book to locate a keyword without reading every word.</p>
                </li>
                <li>
                    <span class="algorithm">Breadth-First Search (BFS)</span>
                    <p class="principle"><strong>Technique:</strong> Explores all possibilities level by level before going deeper.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Finding the shortest path to a destination, like navigating through a city.</p>
                </li>
                <li>
                    <span class="algorithm">Depth-First Search (DFS)</span>
                    <p class="principle"><strong>Technique:</strong> Explores one path as deeply as possible before backtracking.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Navigating a maze by following one path to its end and backtracking if needed.</p>
                </li>
                <li>
                    <span class="algorithm">Knuth-Morris-Pratt (KMP) Algorithm</span>
                    <p class="principle"><strong>Technique:</strong> Uses precomputed information to skip unnecessary comparisons when matching patterns in text.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Quickly finding a specific phrase in a document using a summary index.</p>
                </li>
                <li>
                    <span class="algorithm">Rabin-Karp Algorithm</span>
                    <p class="principle"><strong>Technique:</strong> Converts a pattern and text into numeric hash values to compare them efficiently.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Detecting plagiarism by comparing hash values of documents.</p>
                </li>
            </ul>
        </section>
         <section id="spanning-trees">
            <h2>Spanning Trees (Kruskal’s Algorithm)</h2>
            <ul>
                <li><strong>Purpose:</strong> Connect all nodes in a graph with the minimum number of edges.</li>
                <li><strong>Kruskal’s Algorithm:</strong> Sorts edges by weight and adds them to form a spanning tree, avoiding cycles.</li>
                <li><strong>Real-world Application:</strong> Used in network design (e.g., telecommunications, electricity grids) to minimize connection costs.</li>
            </ul>
        </section>
        <section id="shortest-paths">
            <h2>Shortest Path Algorithms</h2>
            <ul>
                <li><strong>Dijkstra’s Algorithm:</strong> Finds the shortest path from a single source node to all other nodes in a graph with non-negative edge weights.</li>
                <li><strong>Real-world Application:</strong> Used in GPS systems and network routing to find the quickest or least costly path.</li>
                <li><strong>Floyd-Warshall Algorithm:</strong> Finds shortest paths between all pairs of nodes in a graph.</li>
                <li><strong>Real-world Application:</strong> Ideal for analyzing all possible routes in transportation networks or social networks.</li>
                <li><strong>Prim’s Algorithm:</strong> Builds a minimum spanning tree by adding the nearest node to the growing tree.</li>
                <li><strong>Real-world Application:</strong> Used in network optimization where the goal is to connect all nodes at minimal cost.</li>
            </ul>
        </section>
        <h2>Algorithm Design techniques</h2>
       <section id="sorting">
            <h2>Sorting Algorithms</h2>
            <ul>
                <li><strong>Bubble Sort</strong>: Repeatedly swaps adjacent elements to sort.</li>
                <li><strong>Selection Sort</strong>: Selects the minimum element and places it in the correct position.</li>
                <li><strong>Insertion Sort</strong>: Inserts elements into their correct position one by one.</li>
                <li><strong>Merge Sort</strong>: Divides and merges sorted subarrays.</li>
                <li><strong>Quick Sort</strong>: Partitions and recursively sorts subarrays.</li>
                <li><strong>Heap Sort</strong>: Uses a heap structure to sort elements.</li>
            </ul>
        </section>

        <section id="searching">
            <h2>Searching Algorithms</h2>
            <ul>
                <li><strong>Linear Search</strong>: Searches elements sequentially.</li>
                <li><strong>Binary Search</strong>: Efficient search in sorted arrays by halving the search space.</li>
            </ul>
        </section>

        <section id="stringMatching">
            <h2>String Matching Algorithms</h2>
            <ul>
                <li><strong>Brute Force</strong>: Compares substrings directly.</li>
                <li><strong>KMP (Knuth-Morris-Pratt)</strong>: Efficient pattern matching using preprocessing.</li>
                <li><strong>Rabin-Karp</strong>: Hashing-based string matching.</li>
                <li><strong>Boyer-Moore</strong>: Optimized string search using bad-character heuristics.</li>
            </ul>
        </section>

        <!--  <section id="graph">
            <h2>Graph Algorithms</h2>
            <ul>
                <li><strong>Depth-First Search (DFS)</strong>: Traverses a graph deeply before backtracking.</li>
                <li><strong>Breadth-First Search (BFS)</strong>: Traverses a graph level by level.</li>
                <li><strong>Dijkstra’s Shortest Path Algorithm</strong>: Finds the shortest path in weighted graphs (without negative weights).</li>
                <li><strong>Bellman-Ford Algorithm</strong>: Similar to Dijkstra’s but supports negative weights.</li>
                <li><strong>Floyd-Warshall Algorithm</strong>: Finds shortest paths between all pairs of vertices.</li>
                <li><strong>Prim’s and Kruskal’s Minimum Spanning Tree Algorithms</strong>: Finds the minimum spanning tree of a graph.</li>
            </ul>
        </section>

        <section id="optimization">
            <h2>Optimization and Problem-Specific Algorithms</h2>
            <ul>
                <li><strong>Union-Find (Disjoint Set Union)</strong>: Efficiently handles union and find operations in dynamic sets.</li>
            </ul>
        </section>    -->
        <h1 style="color: blue;">Algorithm Design Techniques</h1>

<h2 style="color: purple;">1. Backtracking</h2>
<ul>
    <li><strong>Incrementally build solutions and retract choices when constraints are violated.</strong></li>
    <li><strong>Strength:</strong> Suitable for problems that require exploring all possibilities with constraints.</li>
    <li><strong>Examples of Algorithms:</strong>
        <ul>
            <li><strong>N-Queens Problem:</strong> Place queens on a chessboard avoiding conflicts.</li>
            <li><strong>Sudoku Solver:</strong> Fill cells while adhering to Sudoku rules.</li>
        </ul>
    </li>
</ul>

<h2 style="color: purple;">2. Divide and Conquer</h2>
<ul>
    <li><strong>Break a problem into smaller subproblems, solve them independently, and combine their solutions.</strong></li>
    <li><strong>Strength:</strong> Efficient for problems with no overlapping subproblems and clear substructure.</li>
    <li><strong>Examples of Algorithms:</strong>
        <ul>
            <li><strong>Binary Search:</strong> Recursively search in halves of a sorted array.</li>
            <li><strong>Merge Sort:</strong> Recursively split and merge sorted arrays.</li>
            <li><strong>Quick Sort:</strong> Partition around a pivot and sort subarrays recursively.</li>
        </ul>
    </li>
</ul>

<h2 style="color: purple;">3. Partitioning</h2>
<ul>
    <li><strong>Divide data into segments or partitions to simplify solving the problem.</strong></li>
    <li><strong>Strength:</strong> Enables efficient division of input for sorting, clustering, or divide-and-conquer methods.</li>
    <li><strong>Examples of Algorithms:</strong>
        <ul>
            <li><strong>Quick Sort Partitioning:</strong> Rearrange elements around a pivot.</li>
        </ul>
    </li>
</ul>

<h2 style="color: purple;">4. Greedy Algorithms</h2>
<ul>
    <li><strong>Make locally optimal choices to aim for a globally optimal solution.</strong></li>
    <li><strong>Strength:</strong> Simple and fast when the greedy choice leads to an optimal solution.</li>
    <li><strong>Examples of Algorithms:</strong>
        <ul>
            <li><strong>Kruskal's Algorithm:</strong> Add smallest edges to form a Minimum Spanning Tree.</li>
            <li><strong>Dijkstra's Algorithm:</strong> Iteratively find shortest paths from a source.</li>
        </ul>
    </li>
</ul>

        
    </main>
    <footer>
        <p>&copy; 2024 Shreyas Kulkarni. All rights reserved.</p>
    </footer>
</body>
</html>
