<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts and Applications</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        ul li p {
            margin-left: 20px; /* Optional for better readability */
            display: block;
        }
    </style>
</head>
<body>
    <header>
        <h1>Algorithm Concepts and Applications</h1>
        <p>A detailed overview of how algorithms relate to everyday problems and advanced scenarios.</p>
    </header>
    <nav>
        <ul>
            <li><a href="#nature-problems">Problems in Nature</a></li>
            <li><a href="#efficiency">Efficiency Measures</a></li>
            <li><a href="#fundamental-techniques">Fundamental Techniques</a></li>
            <li><a href="#tree-structures">Tree Data Structures</a></li>
            <li><a href="#array-queries">Array Query Algorithms</a></li>
            <li><a href="#sorting-algorithms">Sorting Algorithms</a></li>
            <li><a href="#searching-algorithms">Searching Algorithms</a></li>
        </ul>
    </nav>
    <main>
        <section id="nature-problems">
            <h2>1. Problems We See in Nature Related to Algorithms</h2>
            <ul>
                <li>Searching for food in a menu.</li>
                <li>Arranging vegetables from the market.</li>
                <li>Adding ingredients while preparing food.</li>
                <li>Finding a lost key (search problem).</li>
                <li>Drawing rangoli patterns (recursion).</li>
                <li>Cleaning the floor (Breadth-First Search).</li>
                <li>Traveling to new locations (Shortest Path Algorithm).</li>
            </ul>
        </section>
        <section id="efficiency">
            <h2>2. Time and Space Efficiency</h2>
            <p>Time-efficiency is the amount of time the basic operation/algorithm takes to execute as a function of input size or its magnitude. 
            Space-efficiency is the extra memory taken by the algorithm. 
            Both are important for designing sustainable solutions.</p>
            <h3>Orders of Growth</h3>
            <p>The growth rates of algorithms are classified as:</p>
            <pre>O(1) < O(log(n)) < O(n) < O(n log(n)) < O(n²) < O(n³) < O(2ⁿ) < O(n!)</pre>
        </section>
        <section id="fundamental-techniques">
            <h2>3. Fundamental Techniques</h2>
            <ul>
                <li><strong>Decomposition:</strong> Break complex problems into smaller, manageable sub-problems for focused solutions.</li>
                <li><strong>Pattern Recognition:</strong> Identify recurring patterns to generalize solutions and apply knowledge across domains.</li>
                <li><strong>Abstraction:</strong> Focus on essential features while ignoring irrelevant details to simplify problem-solving.</li>
                <li><strong>Traversal Techniques:</strong></li>
                <ul>
                    <li>Brave Traversal: Depth-first exploration (DFS).</li>
                    <li>Cautious Traversal: Level-wise exploration (BFS).</li>
                </ul>
                <li><strong>Pruning:</strong> Eliminate unnecessary parts of a problem to improve efficiency (e.g., N-Queens problem).</li>
                <li><strong>Lazy Propagation:</strong> Optimize range updates in data structures by deferring computations.</li>
                <li><strong>Sliding Window:</strong> Efficiently analyze overlapping sub-arrays or sequences.</li>
                <li><strong>Level Order Traversal:</strong> Explore tree nodes breadth-wise (used in BFS).</li>
                <li><strong>Hierarchical Data:</strong> Organize data in parent-child relationships for efficient management (e.g., tree structures).</li>
                <li><strong>Edge Relaxation:</strong> Update shortest path estimates in weighted graphs.</li>
                <li><strong>Balancing and Rotations:</strong> Maintain balanced trees for optimal performance (e.g., AVL, Red-Black trees).</li>
                <li><strong>Kleene Closure:</strong> Apply transitive properties for pathfinding and graph analysis.</li>
                <li><strong>Pre-Computing:</strong> Store frequently used results to avoid redundant calculations (e.g., lookup tables).</li>
                <li><strong>Parental Dominance:</strong> Maintain parent-child relationships for efficiency (e.g., heaps).</li>
                <li><strong>Prefix and Suffix:</strong> Useful for string manipulation and pattern matching.</li>
                <li><strong>Partitioning:</strong> Divide problems into smaller parts for efficient solutions (e.g., divide-and-conquer).</li>
                <li><strong>Bit Manipulations:</strong> Perform low-level binary operations for optimized algorithms.</li>
                <li><strong>Memoization:</strong> Store results of recursive calls to avoid redundant computations (dynamic programming).</li>
                <li><strong>Invariants:</strong> Ensure conditions remain constant to validate algorithms.</li>
                <li><strong>Shortest Path Trees:</strong> Represent shortest paths in graphs for routing and optimization tasks.</li>
            </ul>
        </section>
        <section id="tree-structures">
            <h2>4. Tree Data Structures</h2>
            <p>Hierarchical data structures help solve and optimize various problems:</p>
            <ul>
                <li><strong>Tree:</strong> Basic structure for relationships.</li>
                <li><strong>Binary Search Tree (BST):</strong> Ordered structure for efficient search, insert, and delete operations.</li>
                <li><strong>2-3 Tree:</strong> Always balanced for consistent performance.</li>
                <li><strong>AVL Tree:</strong> Self-balances for faster searches.</li>
                <li><strong>Red-Black Tree:</strong> Faster insertions and deletions due to simpler balancing.</li>
                <li><strong>Trie:</strong> Ideal for word searches and prefix matches.</li>
                <li><strong>Heap:</strong> Efficient for finding min/max in priority queues.</li>
            </ul>
        </section>
      <section id="array-queries">
    <h2>4. Array Query Algorithms</h2>
    <p>Array query algorithms handle range queries and updates effectively by using efficient data structures:</p>
    <ul>
        <li>
            <strong>Lookup Table</strong>
            <p><strong>Principle:</strong> Precomputes answers for different inputs and stores them in a table. 
                When queried, answers are retrieved in O(1) time using a 2D matrix.</p>
            <p><strong>Application:</strong> Useful when we need to answer multiple queries very quickly after an 
                initial precomputation (e.g., computing factorials).</p>
        </li>
        <li>
            <strong>Segment Tree</strong>
            <p><strong>Principle:</strong> A tree-like data structure that divides the array into smaller parts 
                (segments) and stores information about them. It can quickly answer range queries (like sum or 
                minimum) and also update elements.</p>
            <p><strong>Application:</strong> Used in problems involving arrays to answer range queries, such as in 
                games or dynamic programming problems.</p>
        </li>
        <li>
            <strong>Sparse Table</strong>
            <p><strong>Principle:</strong> Optimized for answering range queries where no updates are needed. It uses 
                precomputation to quickly find minimums or maximums over a range.</p>
            <p><strong>Application:</strong> Ideal for answering static range queries efficiently (e.g., finding the 
                minimum or maximum over a range).</p>
        </li>
        <li>
            <strong>Binary Indexed Tree (Fenwick Tree)</strong>
            <p><strong>Principle:</strong> A binary tree structure that helps quickly compute prefix sums (sum of 
                elements from the start of the array to a specific index) and update elements in the array.</p>
            <p><strong>Application:</strong> Used in problems requiring efficient updates and prefix sum queries, like 
                stock price tracking.</p>
        </li>
    </ul>
</section>
<section id="sorting-algorithms">
            <h2>5. Sorting Algorithms</h2>
            <p>Sorting helps organize data, making it easier to search, process, or analyze.</p>

            <ul>
                <li>
                    <span class="algorithm">Bubble Sort</span>
                    <p class="principle"><strong>Technique:</strong> Compares adjacent elements and swaps them if they are in the wrong order. Repeats until no swaps are needed.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Like bubbling the smallest objects to the surface when shaking a jar of mixed items.</p>
                </li>
                <li>
                    <span class="algorithm">Selection Sort</span>
                    <p class="principle"><strong>Technique:</strong> Finds the smallest (or largest) element and places it at the correct position in the sorted list, repeating for all elements.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Selecting the cheapest items from a shelf and arranging them in price order.</p>
                </li>
                <li>
                    <span class="algorithm">Insertion Sort</span>
                    <p class="principle"><strong>Technique:</strong> Picks one item at a time from the unsorted portion and places it in the correct position in the sorted portion.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Sorting playing cards in your hand while playing a game.</p>
                </li>
                <li>
                    <span class="algorithm">Merge Sort</span>
                    <p class="principle"><strong>Technique:</strong> Divides the list into halves, sorts each half, and merges the sorted halves.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Merging two sorted piles of papers into one sorted pile.</p>
                </li>
                <li>
                    <span class="algorithm">Quick Sort</span>
                    <p class="principle"><strong>Technique:</strong> Picks a "pivot" and rearranges items into smaller or larger groups based on the pivot. Recursively sorts each group.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Organizing books on a shelf by picking a reference book and grouping others around it.</p>
                </li>
                <li>
                    <span class="algorithm">Heap Sort</span>
                    <p class="principle"><strong>Technique:</strong> Builds a special tree (heap) to always extract the largest or smallest item and sort the list.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Organizing tasks by priority and completing the most urgent ones first.</p>
                </li>
            </ul>
        </section>

        <section id="searching-algorithms">
            <h2>Searching Algorithms</h2>
            <p>Searching helps locate specific information quickly in large datasets.</p>

            <ul>
                <li>
                    <span class="algorithm">Boyer-Moore Algorithm</span>
                    <p class="principle"><strong>Technique:</strong> Skips unnecessary comparisons when searching for a pattern in a text by using the last occurrence of characters.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Skimming through a book to locate a keyword without reading every word.</p>
                </li>
                <li>
                    <span class="algorithm">Breadth-First Search (BFS)</span>
                    <p class="principle"><strong>Technique:</strong> Explores all possibilities level by level before going deeper.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Finding the shortest path to a destination, like navigating through a city.</p>
                </li>
                <li>
                    <span class="algorithm">Depth-First Search (DFS)</span>
                    <p class="principle"><strong>Technique:</strong> Explores one path as deeply as possible before backtracking.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Navigating a maze by following one path to its end and backtracking if needed.</p>
                </li>
                <li>
                    <span class="algorithm">Knuth-Morris-Pratt (KMP) Algorithm</span>
                    <p class="principle"><strong>Technique:</strong> Uses precomputed information to skip unnecessary comparisons when matching patterns in text.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Quickly finding a specific phrase in a document using a summary index.</p>
                </li>
                <li>
                    <span class="algorithm">Rabin-Karp Algorithm</span>
                    <p class="principle"><strong>Technique:</strong> Converts a pattern and text into numeric hash values to compare them efficiently.</p>
                    <p class="connection"><strong>Real-World Connection:</strong> Detecting plagiarism by comparing hash values of documents.</p>
                </li>
            </ul>
        </section>
                

    </main>
    <footer>
        <p>&copy; 2024 Shreyas Kulkarni. All rights reserved.</p>
    </footer>
</body>
</html>
