<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts and Applications</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Algorithm Concepts and Applications</h1>
        <p>A detailed overview of how algorithms relate to everyday problems and advanced scenarios.</p>
    </header>
    <nav>
        <ul>
            <li><a href="#nature-problems">Problems in Nature</a></li>
            <li><a href="#efficiency">Efficiency Measures</a></li>
            <li><a href="#fundamental-techniques">Fundamental Techniques</a></li>
            <li><a href="#tree-structures">Tree Data Structures</a></li>
            <li><a href="#array-queries">Array Query Algorithms</a></li>
        </ul>
    </nav>
    <main>
        <section id="nature-problems">
            <h2>1. Problems We See in Nature Related to Algorithms</h2>
            <ul>
                <li>Searching for food in a menu.</li>
                <li>Arranging vegetables from the market.</li>
                <li>Adding ingredients while preparing food.</li>
                <li>Finding a lost key (search problem).</li>
                <li>Drawing rangoli patterns (recursion).</li>
                <li>Cleaning the floor (Breadth-First Search).</li>
                <li>Traveling to new locations (Shortest Path Algorithm).</li>
            </ul>
        </section>
        <section id="efficiency">
            <h2>2. Time and Space Efficiency</h2>
            <p>Time-efficiency is the amount of time the basic operation/algorithm takes to execute as a function of input size or its magnitude. 
            Space-efficiency is the extra memory taken by the algorithm. 
            Both are important for designing sustainable solutions.</p>
            <h3>Orders of Growth</h3>
            <p>The growth rates of algorithms are classified as:</p>
            <pre>O(1) < O(log(n)) < O(n) < O(n log(n)) < O(n²) < O(n³) < O(2ⁿ) < O(n!)</pre>
        </section>
        <section id="fundamental-techniques">
            <h2>3. Fundamental Techniques</h2>
            <ul>
                <li><strong>Decomposition:</strong> Break complex problems into smaller, manageable sub-problems for focused solutions.</li>
                <li><strong>Pattern Recognition:</strong> Identify recurring patterns to generalize solutions and apply knowledge across domains.</li>
                <li><strong>Abstraction:</strong> Focus on essential features while ignoring irrelevant details to simplify problem-solving.</li>
                <li><strong>Traversal Techniques:</strong></li>
                <ul>
                    <li>Brave Traversal: Depth-first exploration (DFS).</li>
                    <li>Cautious Traversal: Level-wise exploration (BFS).</li>
                </ul>
                <li><strong>Pruning:</strong> Eliminate unnecessary parts of a problem to improve efficiency (e.g., N-Queens problem).</li>
                <li><strong>Lazy Propagation:</strong> Optimize range updates in data structures by deferring computations.</li>
                <li><strong>Sliding Window:</strong> Efficiently analyze overlapping sub-arrays or sequences.</li>
                <li><strong>Level Order Traversal:</strong> Explore tree nodes breadth-wise (used in BFS).</li>
                <li><strong>Hierarchical Data:</strong> Organize data in parent-child relationships for efficient management (e.g., tree structures).</li>
                <li><strong>Edge Relaxation:</strong> Update shortest path estimates in weighted graphs.</li>
                <li><strong>Balancing and Rotations:</strong> Maintain balanced trees for optimal performance (e.g., AVL, Red-Black trees).</li>
                <li><strong>Kleene Closure:</strong> Apply transitive properties for pathfinding and graph analysis.</li>
                <li><strong>Pre-Computing:</strong> Store frequently used results to avoid redundant calculations (e.g., lookup tables).</li>
                <li><strong>Parental Dominance:</strong> Maintain parent-child relationships for efficiency (e.g., heaps).</li>
                <li><strong>Prefix and Suffix:</strong> Useful for string manipulation and pattern matching.</li>
                <li><strong>Partitioning:</strong> Divide problems into smaller parts for efficient solutions (e.g., divide-and-conquer).</li>
                <li><strong>Bit Manipulations:</strong> Perform low-level binary operations for optimized algorithms.</li>
                <li><strong>Memoization:</strong> Store results of recursive calls to avoid redundant computations (dynamic programming).</li>
                <li><strong>Invariants:</strong> Ensure conditions remain constant to validate algorithms.</li>
                <li><strong>Shortest Path Trees:</strong> Represent shortest paths in graphs for routing and optimization tasks.</li>
            </ul>
        </section>
        <section id="tree-structures">
            <h2>4. Tree Data Structures</h2>
            <p>Hierarchical data structures help solve and optimize various problems:</p>
            <ul>
                <li><strong>Tree:</strong> Basic structure for relationships.</li>
                <li><strong>Binary Search Tree (BST):</strong> Ordered structure for efficient search, insert, and delete operations.</li>
                <li><strong>2-3 Tree:</strong> Always balanced for consistent performance.</li>
                <li><strong>AVL Tree:</strong> Self-balances for faster searches.</li>
                <li><strong>Red-Black Tree:</strong> Faster insertions and deletions due to simpler balancing.</li>
                <li><strong>Trie:</strong> Ideal for word searches and prefix matches.</li>
                <li><strong>Heap:</strong> Efficient for finding min/max in priority queues.</li>
            </ul>
        </section>
        <section id="array-queries">
    <h2>4. Array Query Algorithms</h2>
    <p>Array query algorithms handle range queries and updates effectively by using efficient data structures:</p>
    <ul>
        <li>
            <strong>Lookup Table:</strong>
            <p>
                <strong>Principle:</strong> Precomputes answers for different inputs and stores them in a table. 
                When queried, answers are retrieved in O(1) time using a 2D matrix.
            </p>
            <p>
                <strong>Application:</strong> Useful when we need to answer multiple queries very quickly after an 
                initial precomputation (e.g., computing factorials).
            </p>
        </li>
        <li>
            <strong>Segment Tree:</strong>
            <p>
                <strong>Principle:</strong> A tree-like data structure that divides the array into smaller parts 
                (segments) and stores information about them. It can quickly answer range queries (like sum or minimum) 
                and also update elements.
            </p>
            <p>
                <strong>Application:</strong> Used in problems involving arrays to answer range queries, such as in 
                games or dynamic programming problems.
            </p>
        </li>
        <li>
            <strong>Sparse Table:</strong>
            <p>
                <strong>Principle:</strong> Optimized for answering range queries where no updates are needed. It uses 
                precomputation to quickly find minimums or maximums over a range.
            </p>
            <p>
                <strong>Application:</strong> Ideal for answering static range queries efficiently (e.g., finding the 
                minimum or maximum over a range).
            </p>
        </li>
        <li>
            <strong>Binary Indexed Tree (Fenwick Tree):</strong>
            <p>
                <strong>Principle:</strong> A binary tree structure that helps quickly compute prefix sums (sum of 
                elements from the start of the array to a specific index) and update elements in the array.
            </p>
            <p>
                <strong>Application:</strong> Used in problems requiring efficient updates and prefix sum queries, like 
                stock price tracking.
            </p>
        </li>
    </ul>
</section>

    </main>
    <footer>
        <p>&copy; 2024 Shreyas Kulkarni. All rights reserved.</p>
    </footer>
</body>
</html>
