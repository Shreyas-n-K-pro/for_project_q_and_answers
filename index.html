<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts and Applications</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Algorithm Concepts and Applications</h1>
        <p>A detailed overview of how algorithms relate to everyday problems and advanced scenarios.</p>
    </header>
    <nav>
        <ul>
            <li><a href="#nature-problems">Problems in Nature</a></li>
            <li><a href="#efficiency">Efficiency Measures</a></li>
            <li><a href="#tree-structures">Tree Data Structures</a></li>
            <li><a href="#array-queries">Array Query Algorithms</a></li>
        </ul>
    </nav>
    <main>
        <section id="nature-problems">
            <h2>1. Problems We See in Nature Related to Algorithms</h2>
            <ul>
                <li>Searching for food in a menu.</li>
                <li>Arranging vegetables from the market.</li>
                <li>Adding ingredients while preparing food.</li>
                <li>Finding a lost key (search problem).</li>
                <li>Drawing rangoli patterns (recursion).</li>
                <li>Cleaning the floor (Breadth-First Search).</li>
                <li>Traveling to new locations (Shortest Path Algorithm).</li>
            </ul>
        </section>
        <section id="efficiency">
            <h2>2. Time and Space Efficiency</h2>
            <p>Time-efficiency measures how long an algorithm takes to execute based on input size. Space-efficiency refers to the additional memory required. Both are crucial for designing sustainable solutions.</p>
            <h3>Orders of Growth</h3>
            <p>The growth rates of algorithms are classified as:</p>
            <pre>O(1) < O(log(n)) < O(n) < O(n log(n)) < O(n²) < O(n³) < O(2ⁿ) < O(n!)</pre>
        </section>
        <section id="tree-structures">
            <h2>3. Tree Data Structures</h2>
            <p>Hierarchical data structures help solve and optimize various problems:</p>
            <ul>
                <li><strong>Tree:</strong> Basic structure for relationships.</li>
                <li><strong>Binary Search Tree (BST):</strong> Ordered structure for efficient search, insert, and delete operations.</li>
                <li><strong>2-3 Tree:</strong> Always balanced for consistent performance.</li>
                <li><strong>AVL Tree:</strong> Self-balances for faster searches.</li>
                <li><strong>Red-Black Tree:</strong> Faster insertions and deletions due to simpler balancing.</li>
                <li><strong>Trie:</strong> Ideal for word searches and prefix matches.</li>
                <li><strong>Heap:</strong> Efficient for finding min/max in priority queues.</li>
            </ul>
        </section>
        <section id="array-queries">
            <h2>4. Array Query Algorithms</h2>
            <p>Array query algorithms handle range queries and updates effectively:</p>
            <ul>
                <li><strong>Lookup Table:</strong> Precomputes results for quick retrieval (O(1) time).</li>
                <li><strong>Segment Tree:</strong> Handles range queries and updates dynamically.</li>
                <li><strong>Sparse Table:</strong> Optimized for static range queries (e.g., min/max).</li>
                <li><strong>Binary Indexed Tree:</strong> Efficient for prefix sum queries and updates.</li>
            </ul>
        </section>
    </main>
    <footer>
        <p>&copy; 2024 Shreyas Kulkarni. All rights reserved.</p>
    </footer>
</body>
</html>
